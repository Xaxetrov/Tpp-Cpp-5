\documentclass[a4paper, 12pts]{article}

\usepackage[top=3.5cm, bottom=3.5cm, left=3cm, right=3cm]{geometry}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{authblk} %author tools
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[normalem]{ulem}

%\usepackage{hyperref} %pour les liens internet

%\usepackage{graphicx} %pour les images
\title{TP4 C++ : Héritage et polymorphisme \\
    \large Conception}
\author{Edern HAUMONT}
\author{Théo THIBAULT}
\affil{B3133}
\date{\today}

%-----------------------------------------------------------------------------------------

\begin{document}

%\begin{titlepage}

\maketitle

%\end{titlepage}

%----------------------------------------------Title end

\section{Introduction}
	This is the document of conception of the application. It is ended by a class diagram which summarize its content.

\section{Objects}
    Objects are instanciated Whe the corresponding form is created. They are then added in a map which stores all active objects of the draw.
    \subsection{Point}
        Point is not an object but it composed them. A Point is described by his two coordinates. We need to add a getter and
        a setter so we can read (to check a hit) and update (to move an object) coordinates of a point.
    \subsection{Segment}
        A Segment is made with two points.
        Hit method uses an algorithm that have a configurable precision.
    \subsection{Polygon}
    \subsection{Rectangle}
    \subsection{Multi-Objects}
        Multi-objects, like Reunion or Intersection, are made with other objects. All objects which composed the multi-object are
        stored in a vector of Objects. Multi-object is a derived class of Object, it's permits that a multi-object could be composed
        by other multi-object. Do an action on a multi-object (like a move) means do an action on all objects which composed it.
        Multi-Objects is an abstract class because a multi-object is always an intersection or a reunion.
    \subsection{Reunion}
        Reunion is a kind of multi-object. A point is into a Reunion-Object if it hits any object which composed it.
    \subsection{Intersection}
        Intersection is a kind of multi-object. A point is into a Intersection-Object only if it hits all objects which composed it.

\section{Historic of actions}
    To implement the ability for the user to undo and redo actions, we chose a quite simple model :
    \begin{itemize}
        \item When the user calls a valid action, it is executed.
        \item Meanwhile, the command of this action is registered in a list, detailed later.
        \item The program creates an opposit command which can be executed if the user decides to undo the action.
        This command is stored in another list, but with the same iterator.
        \item Then, when undo and redo are called, we just have to navigate in this list and (re)execute corresponding
        actions
    \end{itemize}

    \subsection{command historic storage}
        Commands are strings which are stored in lists (implemented by a double-linked list in the STL). Their "undo
        counterpart" is stored at the same index but in a different list. We chose to cap the size of both lists to 20,
        which is sufficient for a normal utilisation of the undo possibility. If an action is made but there are
        already 20 commands registered, we erase the oldest to make some space to the new.

\section{Persistance}
    \subsection{Save}
        When the user asks to save the state of the draw, the program take each object of the objects map and call their getCommand method.
        The string returned is the command that can recreate the objects at an identic state. These commands are stored in the desired file.
    \subsection{Load}
        The program simply reads the commands of a given savefile and executes them. Thus, desired objects are imported in the draw.

\end{document}
